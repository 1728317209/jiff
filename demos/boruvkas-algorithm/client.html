<html>
  <head>
    <title></title>
    <meta content="">
    <style>
      #cy {
        width: 650px;
        height: 650px;
        display: block;
        border:2px solid black;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.2.11/cytoscape.min.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/lib/sodium.js"></script>
    <script src="/lib/jiff-client.js"></script>
  </head>
  <body>
    <h1>Connect JIFF</h1>
    <label for="computation_id">Computation ID</label><input id="computation_id" value="test"></input><br/><br/>
    <label for="count">Party Count<label> <input id="count" pattern="[0-9]*"> &nbsp; <button id="connectButton" onclick="connect();">Connect</button>
    <br/><br/>
    <hr/>
    <h1>Minimal Spanning Tree Using Boruvka's Algorihtm Under MPC</h1>
    <h3>Input Edges:</h3>
    <label for="start_node">Start Node:</label>
    <input id="start_node"><br/>
    <label for="end_node">End Node:</label>
    <input id="end_node"><br/>
    <label for="weight">Value:</label>
    <input id="weight"><br/>
    <button onclick="addEdge();" disabled="disabled" id="addEdge">Add Edge.</button>
    <button onclick="start();" disabled="disabled" id="start">Start!</button>
    <br/>
    <div id="cy"></div>
    <div id="output"></div>
    <script>
      "use strict";
      var jiff_instance;
      var party_count;
      function connect() {
        $('#connectButton').prop('disabled', true);
        var computation_id = $('#computation_id').val();
        party_count = parseInt($('#count').val());

        if(isNaN(party_count)) {
          $("#output").append("<p class='error'>Party count must be a valid number!</p>");
          $('#connectButton').prop('disabled', false);
        } else {
          var options = { party_count: party_count};
          options.onError = function(error) { $("#output").append("<p class='error'>"+error+"</p>"); };
          options.onConnect = function() {
            $("#addEdge").attr("disabled", false);
            $("#start").attr("disabled", false);
            $("#output").append("<p>All parties Connected!</p>");
            jiff_instance.listen("node-names-list", function(sender, tagList) {
              // if(sender === jiff_instance.id)
              //   return;

              
              sharesAndTags[sender] = [];
              JSON.parse(tagList).forEach(tag => {
                sharesAndTags[sender].push(tag);
              });
              // sharesAndTags[sender] = JSON.parse(list);
              if(Object.keys(sharesAndTags).length == party_count && started)
                startProcessing();
            });
          };
          
          var hostname = window.location.hostname.trim();
          var port = window.location.port;
          if(port == null || port == '') 
            port = "80";
          if(!(hostname.startsWith("http://") || hostname.startsWith("https://")))
            hostname = "http://" + hostname;
          if(hostname.endsWith("/"))
            hostname = hostname.substring(0, hostname.length-1);
  
          hostname = hostname + ":" + port;
          jiff_instance = jiff.make_jiff(hostname, computation_id, options);
        }
      }

      var started = false;
      const sharesAndTags = {};

      var startProcessing = function() {
        $("#output").append("<p>Computation Starting!</p>");

        // preprocessing could be done to reduce mpc overhead

        console.log(edges);
        edges.forEach((edge, i) => { console.log(edge.weight);
          let s = jiff_instance.share(edge.weight);
          for(let p in s) {
            sharesAndTags[p][i]["share"] = s[p];
          }
        });
        
        const nodesList = {}; //convert to Set
        for(let party in sharesAndTags) {
          sharesAndTags[party].forEach(e => {
            if(!(e.start in nodesList)) {
              nodesList[e.start] = {shares:[], arcs:[]};
            }
            nodesList[e.start].shares.push(e.share);
            nodesList[e.start].arcs.push({start:e.start, end:e.end});
            if(!(e.end in nodesList)) {
              nodesList[e.end] = {shares:[], arcs:[]};
            }
            nodesList[e.end].shares.push(e.share);
            nodesList[e.end].arcs.push({start:e.start, end:e.end});
          });
        }

        // var array = [1,3,2];
        // var min = array[0]; // 1
        // var min_index = 0;
        // for(let i = 1; i < array.length; i++) {
        //   var cmp = min < array[i]; // 1 (true)
        //   min = array[i]+(min-array[i]) * cmp; // 3+ (1-3)*1
        //   min_index = min_index + (i-min_index) * !cmp; // 0 + (1 - 0) * 0
        // }

        console.log(nodesList);
        const forest = [];
        const addArcToForest = function(newArc) {
          let added = null;
          for(let i = 0; i < forest.length; i++) {
            let tree = forest[i];
            // tree.forEach(arc => {
            for(let j = 0; j < tree.length; j++) {
              let arc = tree[j];
              if(arc.start === newArc.start ||
                 arc.start === newArc.end || 
                 arc.end === newArc.start || 
                 arc.end === newArc.end) {
                addArcToTree(tree, newArc);
                if(!added)
                  added = tree;
                else {
                  //remove this tree from forest and merge it with "added"
                  added = [...added,...tree];
                  forest.splice(i--, 1);
                }
                break;
              }
            }
          }
          if(!added) 
            forest.push([newArc]);
          console.log("forest"); forest.forEach(t => {console.log('tree'); t.forEach(a => console.log(a))});
        }
        const addArcToTree = function(tree, newArc) {
          for(let i = 0; i < tree.length; i++)
            if((tree[i].start === newArc.start && tree[i].end === newArc.end) || (tree[i].start === newArc.end || tree[i].end === newArc.start))
              return 'dup';
          tree.push(newArc);
          return 'added'
        }
        for(let node in nodesList) {
          if(nodesList[node].shares.length == 1) { console.log(node);
            addArcToForest(nodesList[node].arcs[0]);
            //forest.push(nodesList[node].arcs[0]);
            continue;
          }

          let minimumShare = nodesList[node].shares[0];
          let minimumIndex = 0; //jiff_instance.share(0, 1, [], []); //0;
          for(let i = 1; i < nodesList[node].shares.length; i++) {
            let comparison = minimumShare.lt(nodesList[node].shares[i]);
            minimumShare = nodesList[node].shares[i].add(
              (minimumShare.sub(nodesList[node].shares[i])).mult(comparison)
            );
            if(i == 1)
              minimumIndex = (comparison.mult(minimumIndex - i)).add(i);
            else
              minimumIndex = ((minimumIndex.sub(i)).mult(comparison)).add(i);
          }


          // minimumShare.open(function(minimumShareOpened) {
          //   console.log("minShare:", minimumShareOpened);
          // });
          (function close(n){
          minimumIndex.open(function(minimumIndexOpened) { console.log(n);
            addArcToForest(nodesList[node].arcs[minimumIndexOpened]);
          });
          })(node);
        }

        
      }
      
      const cy = cytoscape({
        container: document.getElementById('cy'), // container to render in

        // there's problem with the position
        // elements: [ // list of graph elements to start with
        //   { // node a
        //     data: { id: 'origin' , position:{x:0, y:0}}
        //   }
        // ],

        style: [ // the stylesheet for the graph
          {
            selector: 'node',
            style: {
              'background-color': '#666',
              'label': 'data(id)'
            }
          },

          {
            selector: 'edge',
            style: {
              'width': 3,
              'line-color': '#ccc',
              'target-arrow-color': '#ccc',
              'target-arrow-shape': 'triangle'
            }
          },
          {
            selector: 'node[type="origin"]',
            style: {
              'background-color': '#666',
              'label': 'data(id)',
              'width':10,
              'height':10
            }
          },
        ],

        layout: {
          name: 'grid',
          rows: 1
        },

        // not working
        // zoom: 221,
        // pan: { x: 0, y: 0 },

      });
      cy.zoom({
        level: 0.8,
        renderedPosition: { x: 300, y: 300 }
      });
      cy.add({
        group: 'nodes',
        data:{ id:'origin', type:'origin', position: {x:0, y:0}}
      });
      cy.getElementById('origin').ungrabify();

      // for adding new vertices at different positions
      let positions = {
        newXPos:100,
        newYPos:0,
        jump:100,
        incrementPos:function() {
          positions.newXPos += positions.jump;
          if(positions.newXPos == 700) {
            positions.newXPos = 0;
            positions.newYPos += positions.jump;
          }
        }
      }

      const edges = [];

      /**
       * Adds an edge to the graph, creating the nodes if they don't exist. 
       */
      function addEdge() {
        let startNode = document.getElementById("start_node").value,
            endNode = document.getElementById("end_node").value,
            weight = document.getElementById("weight").value;
        let parsedWeight = parseFloat(weight);
        if(isNaN(parsedWeight) || parsedWeight != Math.floor(parsedWeight) || parsedWeight < 0) {
          alert('Values must be positive integers only.');
          return;
        }

        // add first node if it doesn't exist
        let node = cy.getElementById(startNode);
        if(node.length == 0) {
          cy.add({
            group: 'nodes', // 'nodes' for a node, 'edges' for an edge
            data: {
              id: startNode, // mandatory (string or number) id for each element, assigned automatically on undefined
            },
            // scratchpad data (usually temp or nonserialisable data)
            scratch: {
              weight:weight
            },

            position: { // the model position of the node (optional on init, mandatory after)
              x: positions.newXPos,
              y: positions.newYPos
            }
          });
          positions.incrementPos();
        }

        // add second node if it doesn't exist
        node = cy.getElementById(endNode);
        if(node.length == 0) {
          cy.add({
            group: 'nodes', // 'nodes' for a node, 'edges' for an edge
            data: {
              id: endNode, // mandatory (string or number) id for each element, assigned automatically on undefined
            },
            // scratchpad data (usually temp or nonserialisable data)
            scratch: {
              weight:parsedWeight
            },

            position: { // the model position of the node (optional on init, mandatory after)
              x: positions.newXPos,
              y: positions.newYPos
            }
          });
          positions.incrementPos();
        }
        
        // add edge between the two nodes
        cy.add({
          group: 'edges',
          data: {
            // label: weight,
            source: startNode,
            target: endNode
          },
          style: {
            label: weight
          }
        });

        // push object to the edges array for mpc
        edges.push({start:startNode, end:endNode, weight:parsedWeight});
      }
      
      /**
       * Start MPC computation. 
       */
      function start() {
        $("#addEdge").attr("disabled", true);
        $("#start").attr("disabled", true);
        started = true;        
        const tagsArray = [];
        edges.forEach(e => {
          tagsArray.push({start:e.start, end:e.end});
        });

        jiff_instance.emit("node-names-list", null, JSON.stringify(tagsArray));
        // if(Object.keys(sharesAndTags).length === party_count - 1)
        //   startProcessing();
      }
    </script>
  </body>
</html>