<html>
  <head>
    <title></title>
    <meta content="">
    <style>
      #cy {
        width: 650px;
        height: 650px;
        display: block;
        border:2px solid black;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.2.11/cytoscape.min.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/lib/sodium.js"></script>
    <script src="/lib/jiff-client.js"></script>
  </head>
  <body>
    <h1>Connect JIFF</h1>
    <label for="computation_id">Computation ID</label><input id="computation_id" value="test"></input><br/><br/>
    <label for="count">Party Count<label> <input id="count" pattern="[0-9]*"> &nbsp; <button id="connectButton" onclick="connect();">Connect</button>
    <br/><br/>
    <hr/>
    <h1>Minimal Spanning Tree Using Boruvka's Algorihtm Under MPC</h1>
    <h3>Input Edges:</h3>
    <label for="start_node">Start Node:</label>
    <input id="start_node"><br/>
    <label for="end_node">End Node:</label>
    <input id="end_node"><br/>
    <label for="weight">Value:</label>
    <input id="weight"><br/>
    <button onclick="addEdge();" disabled="disabled" id="addEdge">Add Edge.</button>
    <button onclick="start();" disabled="disabled" id="start">Start!</button>
    <br/>
    <div id="cy"></div>
    <div id="output"></div>
    <script>
      "use strict";
      var jiff_instance;
      var party_count;

      /**
       * Edges entered by this user.
       */
      const edges = [];

      /**
       * Maps a senderID to an array of objects having the edges and their shares.
       * {senderID -> [{start,end,share}]}
       */
      const sharesAndTags = {};

      /**
       * the forest that should hold the solution tree after the computation.
       * 
       * [{start,end,jiffShare}]
       */
      const forest = [];

      let incompletePromisesCounter = 0;


      function connect() {
        $('#connectButton').prop('disabled', true);
        var computation_id = $('#computation_id').val();
        party_count = parseInt($('#count').val());

        if(isNaN(party_count)) {
          $("#output").append("<p class='error'>Party count must be a valid number!</p>");
          $('#connectButton').prop('disabled', false);
        } else {
          var options = { party_count: party_count };
          options.onError = function(error) { $("#output").append("<p class='error'>"+error+"</p>"); };
          options.onConnect = function() {
            $("#addEdge").attr("disabled", false);
            $("#start").attr("disabled", false);
            $("#output").append("<p>All parties Connected!</p>");
            jiff_instance.listen("node-names-list", function(sender, tagList) {
              sharesAndTags[sender] = JSON.parse(tagList);

              // add missing nodes if any
              sharesAndTags[sender].forEach(tag => {
                let node = cy.getElementById(tag.start);
                if(node.length == 0) {
                  cy.add({
                    group: 'nodes', // 'nodes' for a node, 'edges' for an edge
                    data: {
                      id: tag.start, // mandatory (string or number) id for each element, assigned automatically on undefined
                    },
                    // scratchpad data (usually temp or nonserialisable data)
                    scratch: {
                      weight:weight
                    },

                    position: { // the model position of the node (optional on init, mandatory after)
                      x: positions.newXPos,
                      y: positions.newYPos
                    }
                  });
                  positions.incrementPos();
                }
                node = cy.getElementById(tag.end);
                if(node.length == 0) {
                  cy.add({
                    group: 'nodes', // 'nodes' for a node, 'edges' for an edge
                    data: {
                      id: tag.end, // mandatory (string or number) id for each element, assigned automatically on undefined
                    },
                    // scratchpad data (usually temp or nonserialisable data)
                    scratch: {
                      weight:weight
                    },

                    position: { // the model position of the node (optional on init, mandatory after)
                      x: positions.newXPos,
                      y: positions.newYPos
                    }
                  });
                  positions.incrementPos();
                }
              });

              if(Object.keys(sharesAndTags).length == party_count)
                startProcessing();
            });
          };
          
          var hostname = window.location.hostname.trim();
          var port = window.location.port;
          if(port == null || port == '') 
            port = "80";
          if(!(hostname.startsWith("http://") || hostname.startsWith("https://")))
            hostname = "http://" + hostname;
          if(hostname.endsWith("/"))
            hostname = hostname.substring(0, hostname.length-1);
  
          hostname = hostname + ":" + port;
          jiff_instance = jiff.make_jiff(hostname, computation_id, options);
        }
      }

      var startProcessing = function() {
        $("#output").append("<p>Computation Starting!</p>");

        // preprocessing could be done to reduce mpc overhead

        edges.forEach((edge, i) => {
          let s = jiff_instance.share(edge.weight);
          for(let p in s) {
            sharesAndTags[p][i]["share"] = s[p];
          }
        });
        console.log(sharesAndTags); //complete!

        // populate nodesList
        // for(let party in sharesAndTags) {
        //   sharesAndTags[party].forEach(edge => {
        //     forest.push([edge]);
        //     // forest.forEach(tree => {
        //     //   tree.forEach(node => {
        //     //     // if(node.start === edge.start ||
        //     //     //   node.start === edge.end || 
        //     //     //   node.end === edge.start || 
        //     //     //   node.end === edge.end
        //     //     // ) {

        //     //     // }
        //     //   });
        //     // });
        //   });
        // }
        
        firstIteration();
      }

      const firstIteration = function() {
        /**
         * The array of the arcs touching, but not in, every tree
         */
        const nodesList = {};
        for(let party in sharesAndTags) {
          sharesAndTags[party].forEach(e => {
            // generate nodesList from forest
            if(!(e.start in nodesList)) {
              nodesList[e.start] = [];
            }
            nodesList[e.start].push({start:e.start, end:e.end, share:e.share, ref:e});
            if(!(e.end in nodesList)) {
              nodesList[e.end] = [];
            }
            nodesList[e.end].push({start:e.start, end:e.end, share:e.share, ref:e});
          });
        }

        // var array = [1,3,2];
        // var min = array[0];
        // var min_index = 0;
        // for(let i = 1; i < array.length; i++) {
        //   var cmp = min < array[i];
        //   min = array[i]+(min-array[i]) * cmp;
        //   min_index = min_index + (i-min_index) * !cmp;
        // }

        console.log(nodesList);
        for(let node in nodesList) {
          if(nodesList[node].length == 1) { console.log(node);
            addArcToForest(nodesList[node][0]);
            nodesList[node][0].ref.added = true;
            //forest.push(nodesList[node].arcs[0]);
            continue;
          }

          let minimumShare = nodesList[node][0].share;
          let minimumIndex = 0; //jiff_instance.share(0, 1, [], []);
          for(let i = 1; i < nodesList[node].length; i++) {
            let comparison = minimumShare.lt(nodesList[node][i].share);
            minimumShare = nodesList[node][i].share.add(
              (minimumShare.sub(nodesList[node][i].share)).mult(comparison)
            );
            if(i == 1)
              minimumIndex = (comparison.mult(minimumIndex - i)).add(i);
            else
              minimumIndex = ((minimumIndex.sub(i)).mult(comparison)).add(i);
          }


          // minimumShare.open(function(minimumShareOpened) {
          //   console.log("minShare:", minimumShareOpened);
          // });
          (function close(n) {
            ++incompletePromisesCounter;
            minimumIndex.open(function(minimumIndexOpened) { console.log(n);
              // add share objects with arcs
              addArcToForest(nodesList[node][minimumIndexOpened]);
              if(--incompletePromisesCounter == 0)
                if(forest.length > 1)
                  iterate();
            });
          })(node);
        }
      }

      const iterate = function() { //forest
        //generate node list
        const nodesList = [];
        forest.forEach(tree => {
          let setOfNodes = new Set();
          let l = [];
          tree.forEach(edge => {
            setOfNodes.add(edge.start);
            setOfNodes.add(edge.end);
          });
          for(let party in sharesAndTags) {
            sharesAndTags[party].filter(edge => !edge.added).forEach(edge => { console.log('processing edge', edge, "with tree", tree);
              if(setOfNodes.has(edge.start) && !setOfNodes.has(edge.end)) {
                l.push({start:edge.start, end:edge.end, share:edge.share, ref:edge});
              }
            });
          }
          if(l.length > 0)
            nodesList.push(l);
        });
        console.log(nodesList);
        for(let i = 0; i < nodesList.length; i++) {
          if(nodesList[i].length == 1) {
            addArcToForest(nodesList[i][0]);
            nodesList[i][0].ref.added = true;
            continue;
          }

          let minimumShare = nodesList[i][0].share;
          let minimumIndex = 0;
          for(let j = 1; j < nodesList[i].length; j++) {
            let comparison = minimumShare.lt(nodesList[i][j].share);
            minimumShare = nodesList[i][j].share.add(
              (minimumShare.sub(nodesList[i][j].share)).mult(comparison)
            );
            if(j == 1)
              minimumIndex = (comparison.mult(minimumIndex - j)).add(j);
            else
              minimumIndex = ((minimumIndex.sub(j)).mult(comparison)).add(j);
          }

          (function close(n) {
            ++incompletePromisesCounter;
            minimumIndex.open(function(minimumIndexOpened) { console.log(n);
              // add share objects with arcs
              addArcToForest(nodesList[i][minimumIndexOpened]);
              if(--incompletePromisesCounter == 0)
                if(forest.length > 1)
                  iterate();
            });
          })(node);
        }
      }

      const addArcToForest = function(newArc) { //console.log('==============gonna add', newArc);
        let added = null;
        let indexOfAdded;
        for(let i = 0; i < forest.length; i++) {
          let tree = forest[i]; //console.log('forest now');forest.forEach(t => {console.log('tree'); t.forEach(a => console.log(a))});
          for(let j = 0; j < tree.length; j++) {
            let arc = tree[j]; //console.log('with tree'); tree.forEach(m => {console.log('node', m)}); 
            if(arc.start === newArc.start ||
                arc.start === newArc.end || 
                arc.end === newArc.start || 
                arc.end === newArc.end) {
              if(!added) {
                addArcToTree(tree, newArc);
                displayArc(newArc);
                added = tree;
                indexOfAdded = i;
              }
              else {
                // remove this tree from forest and merge it with "added"
                forest[indexOfAdded] = [...added,...tree];
                forest.splice(i--, 1);
              }
              // console.log("added"); added.forEach(a => {console.log('node', a)});        console.log("forest"); forest.forEach(t => {console.log('tree'); t.forEach(a => console.log(a))});
              break;
            }
          }
        }
        if(!added) {
          forest.push([newArc]);
          displayArc(newArc);
          newArc.ref.added = true;
        }
        console.log("final forest"); forest.forEach(t => {console.log('tree'); t.forEach(a => console.log(a))});
      }
      const addArcToTree = function(tree, newArc) {
        for(let i = 0; i < tree.length; i++)
          if((tree[i].start === newArc.start && tree[i].end === newArc.end)
          || (tree[i].start === newArc.end && tree[i].end === newArc.start))
            return 'dup';
        tree.push(newArc);
        newArc.ref.added = true;
        return 'added';
      }

      const displayArc = function(arc) {
        cy.add({
          group: 'edges',
          data: {
            // label: weight,
            source: arc.start,
            target: arc.end,
            type: 'solution'
          }
        });
      }
    
      const cy = cytoscape({
        container: document.getElementById('cy'), // container to render in

        // there's problem with the position
        // elements: [ // list of graph elements to start with
        //   { // node a
        //     data: { id: 'origin' , position:{x:0, y:0}}
        //   }
        // ],

        style: [ // the stylesheet for the graph
          {
            selector: 'node',
            style: {
              'background-color': '#666',
              'label': 'data(id)'
            }
          },
          {
            selector: 'edge',
            style: {
              'width': 3,
              'line-color': '#ccc',
              'target-arrow-color': '#ccc',
              'target-arrow-shape': 'triangle'
            }
          },
          {
            selector: 'edge[type="solution"]',
            style: {
              'width': 10,
              'line-color': '#f00',
              'target-arrow-color': '#f00',
              'target-arrow-shape': 'triangle'
            }
          },
          {
            selector: 'node[type="origin"]',
            style: {
              'background-color': '#666',
              'label': 'data(id)',
              'width':10,
              'height':10
            }
          },
        ],

        layout: {
          name: 'grid',
          rows: 1
        },

        // not working
        // zoom: 221,
        // pan: { x: 0, y: 0 },

      });
      cy.zoom({
        level: 0.8,
        renderedPosition: { x: 300, y: 300 }
      });
      cy.add({
        group: 'nodes',
        data:{ id:'origin', type:'origin', position: {x:0, y:0}}
      });
      cy.getElementById('origin').ungrabify();

      // for adding new vertices at different positions
      let positions = {
        newXPos:100,
        newYPos:0,
        jump:100,
        incrementPos:function() {
          positions.newXPos += positions.jump;
          if(positions.newXPos == 700) {
            positions.newXPos = 0;
            positions.newYPos += positions.jump;
          }
        }
      }

      /**
       * Adds an edge to the graph, creating the nodes if they don't exist. 
       */
      function addEdge() {
        let startNode = document.getElementById("start_node").value,
            endNode = document.getElementById("end_node").value,
            weight = document.getElementById("weight").value;
        let parsedWeight = parseFloat(weight);
        if(isNaN(parsedWeight) || parsedWeight != Math.floor(parsedWeight) || parsedWeight < 0) {
          alert('Values must be positive integers only.');
          return;
        }

        // add first node if it doesn't exist
        let node = cy.getElementById(startNode);
        if(node.length == 0) {
          cy.add({
            group: 'nodes', // 'nodes' for a node, 'edges' for an edge
            data: {
              id: startNode, // mandatory (string or number) id for each element, assigned automatically on undefined
            },
            // scratchpad data (usually temp or nonserialisable data)
            scratch: {
              weight:weight
            },

            position: { // the model position of the node (optional on init, mandatory after)
              x: positions.newXPos,
              y: positions.newYPos
            }
          });
          positions.incrementPos();
        }

        // add second node if it doesn't exist
        node = cy.getElementById(endNode);
        if(node.length == 0) {
          cy.add({
            group: 'nodes', // 'nodes' for a node, 'edges' for an edge
            data: {
              id: endNode, // mandatory (string or number) id for each element, assigned automatically on undefined
            },
            // scratchpad data (usually temp or nonserialisable data)
            scratch: {
              weight:parsedWeight
            },

            position: { // the model position of the node (optional on init, mandatory after)
              x: positions.newXPos,
              y: positions.newYPos
            }
          });
          positions.incrementPos();
        }
        
        // add edge between the two nodes
        cy.add({
          group: 'edges',
          data: {
            // label: weight,
            source: startNode,
            target: endNode
          },
          style: {
            label: weight
          }
        });

        // push object to the edges array for mpc
        edges.push({start:startNode, end:endNode, weight:parsedWeight});
      }
      
      /**
       * Start MPC computation. 
       */
      function start() {
        $("#addEdge").attr("disabled", true);
        $("#start").attr("disabled", true);
        const tagsArray = [];
        edges.forEach(e => {
          tagsArray.push({start:e.start, end:e.end});
        });

        jiff_instance.emit("node-names-list", null, JSON.stringify(tagsArray));
        // if(Object.keys(sharesAndTags).length === party_count - 1)
        //   startProcessing();
      }
    </script>
  </body>
</html>