<html>
    <head>
        <title>Best Fit Line</title>
        <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.min.js"></script>
        <script src="/socket.io/socket.io.js"></script>
        <script src="/lib/sodium.js"></script>
        <script src="/lib/jiff-client.js"></script>
    </head>
    <body>
        <div style="width:300px; height:300px;">
            <canvas id="myChart" width="400" height="400"></canvas>
        </div>

        <label for="computation_id">Computation ID</label><input id="computation_id" value="test-sum"></input><br/><br/>
        <!--label for="count">Party Count<label> <input id="count" pattern="[0-9]*"><br/><br/-->
        <button id="connectButton" onclick="connect();">Connect</button>
        
        <hr>

        <h4>Please add the appropriate number of values. An axis will be chosen automatically.</h4>
        <input type="radio" id="c1" name="choice" value="x">
        <label for="c1">X</label>
        <input type="radio" id="c2" name="choice" value="y">
        <label for="c2">Y</label>
        <div>Value:</div><input id="val" type="text" placeholder="value"/><br/>
        <button onclick="pushCoordinate()">Add Coordinate!</button>
        <br/><br/>
        <button onclick="calculateLeastSquares(coordinates)">Calculate Least Squares!</button>
        <div id="output"></div>

        <script>
            var jiff_instance;
            function connect() {
                $('#connectButton').prop('disabled', true);
                var computation_id = $('#computation_id').val();
                var party_count = parseInt($('#count').val());

                var options = {party_count:2};
                options.onError = function(error) { $("#output").append("<p class='error'>"+error+"</p>"); };
                options.onConnect = function() {
                    console.log(jiff_instance.id);
                    if(jiff_instance.id == 1)
                        $('input:radio[name=choice]').val(['x']).attr("disabled", true);
                    else
                        $('input:radio[name=choice]').val(['y']).attr("disabled", true);
                    $("#output").append("<p>All parties Connected!</p>");
                };
                
                var hostname = window.location.hostname.trim();
                var port = window.location.port;
                if(port == null || port == '') 
                    port = "80";
                if(!(hostname.startsWith("http://") || hostname.startsWith("https://")))
                    hostname = "http://" + hostname;
                if(hostname.endsWith("/"))
                    hostname = hostname.substring(0, hostname.length-1);
                if(hostname.indexOf(":") > -1)
                    hostanme = hostname.substring(0, hostname.indexOf(":"));
                
                hostname = hostname + ":" + port;
                jiff_instance = jiff.make_jiff(hostname, computation_id, options);
            }
            
            
            // array holds the coordinates input by the user.
            let coordinates = [];

            // array holds data point objects (populated automatically).
            let input_data_points = [];

            // The chart.js graph, ready to receive the coordinates and the line of best fit.
            var ctx = document.getElementById("myChart").getContext('2d');
            var myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        id:"data-points",
                        label:"",
                        data: input_data_points,
                        fill:false,
                        showLine:false,
                        pointBackgroundColor:"rgb(0,0,0)",
                        pointRadius:5
                    },{
                        id:"line",
                        label:"",
                        data: [],
                        fill:false,
                        pointBackgroundColor:"rgb(0,0,0)",
                        borderColor:"rgb(0,0,0)",
                        pointRadius:0.1
                    }]
                },
                options: {
                    scales: {
                        yAxes: [{
                            ticks: {
                                min: -10,
                                max: 10
                            }
                        }],
                        xAxes: [{
                            type: 'linear',
                            position: 'bottom',
                            ticks: {
                                min: -10,
                                max: 10,
                                maxTicksLimit: 20
                            }
                        }]
                    }
                }
            });

            // button onclick event to add a data point to the set of points
            function pushCoordinate() {
                let input = parseInt(document.getElementById("val").value);
                if(isNaN(input))
                    return;

                // push coordinate to the 'coordinates' array
                coordinates.push(input);

                // create a data point object depending on the axis, then push it to the array
                let p;
                if($('input[name=choice]:checked').val() == 'x')
                    p = {x:input,y:0};
                else
                    p = {y:input,x:0};
                input_data_points.push(p);

                myChart.update();
                document.getElementById("val").value = "";
            }

            // button onclick event to calculate least squares
            function calculateLeastSquares(data_points) {
                if(!jiff_instance) {
                    alert("Please connect to jiff server first =)");
                    return;
                }
                

                let this_axis = $('input[name=choice]:checked').val();
                let shares_array = [];
                let sum_x;
                let sum_y;
                let sum_xy = 0;
                let sum_xx;
                let count = 0;

                /*
                * We'll use those variables for faster read/write access.
                */
                let x = 0;
                let y = 0;
                let values_length = values.length;
                if(values_length == 0)
                    return;

                if (values_length === 0) {
                    return [ [], [] ];
                }

                //for(let i = 0; i < values.length; i++)
                //    shares_array[i] = jiff_instance.share(values[i]);

                if(this_axis == 'x') { //this id is 1
                    sum_x = values.reduce((a,c) => a + c);
                    sum_xx = values.reduce((a,c) => a+c*c, 0);
                    //sum_xx = values.reduce((a,c) => { console.log(a); console.log(c); return a + c*c});
                    let t1 = values_length*sum_xx-sum_x*sum_x;

                    console.log(values);
                    let sum_xy;
                    sum_xy = shareAndCalculateSumXY(values);
                    let c__sum_xy = sum_xy.mult(values.length);

                    let sum_x__sum_y = jiff_instance.share(sum_x);
                    sum_x__sum_y = sum_x__sum_y[1].mult(sum_x__sum_y[2]);

                    let mNumerator = c__sum_xy.sub(sum_x__sum_y);

                    let denom = values.length*sum_xx-sum_x*sum_x;
                    denom = jiff_instance.share(denom);
                    denom = denom[1].add(denom[2]);
                    let m = mNumerator.div(denom);

                    m.open(function(m_res) {
                        let m_sum_x_d_count = (m_res*sum_x)/values.length; console.log(m_sum_x_d_count)
                        m_sum_x_d_count = jiff_instance.share(m_sum_x_d_count);
                        let c = m_sum_x_d_count[1].sub(m_sum_x_d_count[2]);
                        c.open(function(c_res) { console.log(c_res);
                            display_after_open(m_res, c_res, this_axis, values);
                        });
                    });

                    // sum_xy.open(function(sum_xy_res) {
                    //     let sum_x__sum_y = jiff_instance.share(sum_x);
                    //     sum_x__sum_y = sum_x__sum_y[1].mult(sum_x__sum_y[2]);

                    //     sum_x__sum_y.open(function(sum_x__sum_y_res) {
                            
                    //     });
                    // });




                    

                    // sum_y = shares_array[0][2]
                    // for(let i = 1; i < values.length; i++)
                    //     sum_y = sum_y.add(shares_array[i][2]);

                    // console.log("past sum_y")
                    // console.log(shares_array);
                    // shares_array.forEach(e => {console.log(e); console.log(e[1]); console.log(e[2]);});

                    // sum_xy = shares_array[0][2].mult(values[0]);
                    // for(let i = 1; i < values.length; i++) {
                    //     sum_xy = sum_xy.add(shares_array[i][2].mult(values[i]));
                    // }

                    // sum_xy.open(function(sum_xy_res) {
                    //     sum_y.open(function(sum_y_res) {
                    //         display_after_open(sum_x,sum_y_res, sum_xy_res, sum_xx, values, this_axis);
                    //     });
                    // });

                } else { //this id is 2
                    sum_y = values.reduce((a,c) => a + c);

                    console.log(values);
                    let sum_xy;
                    sum_xy = shareAndCalculateSumXY(values);
                    let c__sum_xy = sum_xy.mult(values.length);

                    let sum_x__sum_y = jiff_instance.share(sum_y);
                    sum_x__sum_y = sum_x__sum_y[1].mult(sum_x__sum_y[2]);

                    let mNumerator = c__sum_xy.sub(sum_x__sum_y);

                    let denom = jiff_instance.share(0);//null, 2, [1 , 2], [1]);
                    denom = denom[1].add(denom[2]);
                    let m = mNumerator.div(denom);

                    m.open(function(m_res) {
                        let sum_y_d_count = sum_y/values.length; console.log(sum_y_d_count);
                        sum_y_d_count = jiff_instance.share(sum_y_d_count);
                        let c = sum_y_d_count[1].sub(sum_y_d_count[2]);
                        c.open(function(c_res) { console.log(c_res);
                            display_after_open(m_res, c_res, this_axis, values);
                        });
                    });


                    // sum_xy.open(function(sum_xy_res) {
                    //     let sum_x__sum_y = jiff_instance.share(sum_y);
                    //     sum_x__sum_y = sum_x__sum_y[1].mult(sum_x__sum_y[2]);

                    //     sum_x__sum_y.open(function(sum_x__sum_y_res) {

                    //     });
                    // });





                    // sum_x = shares_array[0][1];
                    // for(let i = 1; i < values.length; i++)
                    //     sum_x = sum_x.add(shares_array[i][1]);
                    


                    // sum_x.open(function(sum_x_res) {
                    //     console.log("yey");
                        
                    //     sum_xy = shares_array[0][1].cmult(values[0]);
                    //     for(let i = 1; i < values.length; i++) {
                    //         sum_xy = sum_xy.sadd(shares_array[i][1].cmult(values[i]));
                    //     }

                    //     sum_xy.open(function(sum_xy_res) {
                    //         console.log("yoyh");

                    //         sum_xx = shares_array[0][1].smult(shares_array[0][1]);
                    //         for(let i = 1; i < values.length; i++) {
                    //             sum_xx = sum_xx.sadd(shares_array[i][1].smult(shares_array[i][1]));
                    //         }

                    //         sum_xx.open(function(sum_xx_res) {
                    //             console.log("haJ");
                    //             display_after_open(sum_x_res,sum_y, sum_xy_res, sum_xx_res, values, this_axis);
                    //         })
                    //     });
                    // });


                    // sum_xy = shares_array[0][1].mult(values[0]);
                    // for(let i = 1; i < values.length; i++) {
                    //     sum_xy = sum_xy.add(shares_array[i][1].mult(values[i]));
                    // }

                    // console.log("past sum_xy")
                    // console.log(shares_array);
                    // shares_array.forEach(e => {console.log(e); console.log(e[1]); console.log(e[2]);});



                    // sum_xx = shares_array[0][1].mult(shares_array[0][1]);
                    // for(let i = 1; i < values.length; i++) {
                    //     sum_xx = sum_xx.add(shares_array[i][1].mult(shares_array[i][1]));
                    // }


                    // console.log("past sum_xx")
                    // console.log(shares_array);
                    // shares_array.forEach(e => {console.log(e); console.log(e[1]); console.log(e[2]);});


                    // sum_x.open(function(sum_x_res) { console.log("yey");
                    //     sum_xy.open(function(sum_xy_res) { console.log("yoy");
                    //         sum_xx.open(function(sum_xx_res) { console.log(":(");
                    //             display_after_open(sum_x_res,sum_y, sum_xy_res, sum_xx_res, values, this_axis);
                    //         });
                    //     });
                    // });
                }


                /*
                * The non-mpc calculation that needs to be done
                for (var v = 0; v < values_length; v++) {
                    y = values_y[v];
                    sum_x += x;
                    sum_y += y;
                    sum_xx += x*x;
                    sum_xy += x*y;
                    count++;
                }*/
            }

            
            // function displays the line of best fit on the graph
            function display_after_open(m, b, this_axis, values) {
                console.log("Slope:", m);
                console.log("Y intercept", b);

                var result_values_x = [];
                var result_values_y = [];

                if(this_axis == 'x')
                    for (var v = 0; v < values.length; v++) {
                        x = values[v];
                        y = x * m + b;
                        result_values_x.push(x);
                        result_values_y.push(y);
                    }
                else
                    for (var v = 0; v < values.length; v++) {
                        y = values[v]; //y = mx + b ... x = y
                        x = (y-b)/m;
                        result_values_x.push(x);
                        result_values_y.push(y);
                    }

                let leastSquaresResult = {result_values_x:result_values_x, result_values_y:result_values_y};

                // map result back to data_points
                let leastSquaresDataPoints = [];
                for(let i = 0; i < leastSquaresResult.result_values_x.length /*or y.length*/; i++) {
                    leastSquaresDataPoints.push({
                        x:leastSquaresResult.result_values_x[i],
                        y:leastSquaresResult.result_values_y[i]
                    });
                }
                
                console.log(leastSquaresDataPoints);
                // finally display the line
                updateGraph(leastSquaresDataPoints);
            }

            // A function to calculate sum_xy. This has to be done recursively. 
            function shareAndCalculateSumXY(values) {


                //like in bubble sort
                // let shares_array = [];
                // for(let i = 0; i < values.length; i++) {
                //     shares_array[i] = jiff_instance.share(values[i]);
                // }

                // for(let i = 0; i < shares_array.length; i++) {
                //     shares_array[i] = shares_array[i][1].mult(shares_array[i][2]);
                // }

                // for(let i = 1; i < shares_array.length; i++) {
                //     shares_array[i] = shares_array[i-1].add(shares_array[i]);
                // }

                // let promises = [];
                // for(let i = 0; i < shares_array.length; i++) {
                //     let t = shares_array[i].open(function(res) {
                //         Promise.resolve(res);
                //     });
                //     promises.push(t);
                // }
                // Promise.all(promises).then(function(vals) {
                //     console.log(vals); console.log("^vals")
                // });




                //loop

                
                let sum_xy_res;
                for(let i = 0; i < values.length; i++) {
                    let t = jiff_instance.share(values[i]);
                    t = t[1].mult(t[2]);
                    if(sum_xy_res)
                        sum_xy_res = sum_xy_res.add(t);
                    else
                        sum_xy_res = t;
                }
                return sum_xy_res;


                //rec

                // if(i == values.length)
                //     return sum_xy;
                // let t = jiff_instance.share(values[i]);
                // t = t[1].mult(t[2]);
                // if(i == 0) {
                //     return shareAndCalculateSumXY(i+1, t, values);
                // }
                // sum_xy.add(t);
                // return shareAndCalculateSumXY(i+1, sum_xy, values);
            }

            // print a line on the graph
            function updateGraph(points) {
                let lineDataset = myChart.data.datasets.filter(dataset => dataset.id == "line");
                points.forEach(point => lineDataset[0].data.push(point))
                myChart.update();
            }

            //freeze axis choice once chosen
            // $('input[name=choice]').change(function(){ console.log("here")
            //     $('input[name=choice]').attr("disabled", true);
            // });
        </script>
    </body>
</html>